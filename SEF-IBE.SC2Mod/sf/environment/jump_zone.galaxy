struct sf_envi_jump_zone_t {
    region rg_act;
    fixed distance;
    trigger trig;
};

sf_envi_jump_zone_t [SF_ENVI_OBJECT_INSTANCE_LIMIT]sf_envi_jump_zones;

static void sf_envi_jump_zone_on_destroy(int obj_id)
{
    if (TriggerGetFunction(sf_envi_jump_zones[obj_id].trig) != null) {
        TriggerDestroy(sf_envi_jump_zones[obj_id].trig);
    }
    sf_envi_jump_zones[obj_id].rg_act = null;
    sf_envi_jump_zones[obj_id].distance = 0;
    sf_envi_jump_zones[obj_id].trig = null;
}

void sf_envi_jump_zone_init()
{
    sf_envi_object_type_t obj_type;

    obj_type.name = "jump_zone";
    obj_type.fn_destroy = sf_envi_jump_zone_on_destroy;
    sf_envi_object_register_type_at(obj_type, SF_ENVI_OBJECT_TYPE_JUMP_ZONE);
}

int sf_envi_jump_zone_create(region rg_act, fixed distance)
{
    int obj_id;
    structref<sf_envi_jump_zone_t> jz;

    obj_id = sf_envi_object_create(SF_ENVI_OBJECT_TYPE_JUMP_ZONE);
    jz = sf_envi_jump_zones[obj_id];

    jz.rg_act = rg_act;
    jz.distance = distance;
    // TODO: reuse same trigger between objects
    if (TriggerFind("sf_envi_on_jump_zone_enter") == null) {
        TriggerCreate("sf_envi_on_jump_zone_enter");
    }
    jz.trig = TriggerFind("sf_envi_on_jump_zone_enter");
    TriggerAddEventUnitRegion(jz.trig, null, jz.rg_act, true);

    return obj_id;
}

bool sf_envi_on_jump_zone_enter(bool testConds, bool runActions) {
    int i;
    int obj_id;
    structref<sf_envi_jump_zone_t> jz;
    region tmp_rg;
    unit tmp_unit;
    structref<HERO> hero;
    fixed approach_angle;
    point destination;

    tmp_unit = EventUnit();
    tmp_rg = EventUnitRegion();

    if (!UnitGroupHasUnit(gm_herogroup, tmp_unit)) {
        return false;
    }

    if (sf_phys_is_unit_during_jump(tmp_unit)) {
        return false;
    }

    // find out obj id
    for (i = 0; i < SF_ENVI_OBJECT_INSTANCE_LIMIT; i += 1) {
        if (sf_envi_jump_zones[i].rg_act == tmp_rg) {
            obj_id = i;
            jz = sf_envi_jump_zones[obj_id];
            break;
        }
    }
    if (i == SF_ENVI_OBJECT_INSTANCE_LIMIT) {
        return false;
    }

    hero = gm_players[gm_getPlayerByUnit(tmp_unit)].hero;
    destination = PointWithOffsetPolar(
        UnitGetPosition(tmp_unit),
        jz.distance,
        UnitGetFacing(hero.guideUnit)
    );

    sf_phys_jump_launch(tmp_unit, destination, 2.0 + jz.distance / 10.0, 0.0);

    return true;
}
