struct sf_envi_turn_forcer_t {
    int auto_rotate;
    fixed degrees_per_second;
    fixed value_per_step;
    fixed steps_left;
    trigger trig_range_in;
    trigger trig_range_out;
};

sf_envi_turn_forcer_t [SF_ENVI_OBJECT_INSTANCE_LIMIT]sf_envi_turn_forcers;

unitgroup sf_envi_turn_forcer_automated_group = UnitGroupEmpty();
trigger sf_envi_turn_forcer_trig_periodic = null;

static void sf_envi_turn_forcer_on_destroy(int obj_id)
{
    if (TriggerGetFunction(sf_envi_turn_forcers[obj_id].trig_range_in) != null) {
        TriggerDestroy(sf_envi_turn_forcers[obj_id].trig_range_in);
        sf_envi_turn_forcers[obj_id].trig_range_in = null;
    }
    if (TriggerGetFunction(sf_envi_turn_forcers[obj_id].trig_range_out) != null) {
        TriggerDestroy(sf_envi_turn_forcers[obj_id].trig_range_out);
        sf_envi_turn_forcers[obj_id].trig_range_out = null;
    }
    sf_envi_turn_forcers[obj_id].auto_rotate = 0;
    sf_envi_turn_forcers[obj_id].degrees_per_second = 0.0;
}

static bool sf_envi_turn_forcer_process_range(unit munit, unit tufr_unit, bool in)
{
    structref<HERO> hero;

    if (!UnitGroupHasUnit(gm_herogroup, munit)) {
        return false;
    }

    if (sf_phys_is_unit_during_jump(munit)) {
        return false;
    }

    if (!UnitTestState(munit, c_unitStateRadarable)) {
        return false;
    }

    hero = gm_players[gm_getPlayerByUnit(munit)].hero;

    if (in) {
        hero.supress_turn = true;
        hero.noTurnProcess = false;
        hero.desiredAngle = UnitGetFacing(tufr_unit);
        UnitSetFacing(hero.mainUnit, hero.desiredAngle, TURN_SPEED_ICE);
        UnitSetFacing(hero.guideUnit, hero.desiredAngle, TURN_SPEED_ICE);
    }
    else {
        hero.supress_turn = false;
    }

    return true;
}

void sf_envi_turn_forcer_cleanup()
{
    UnitGroupClear(sf_envi_turn_forcer_automated_group);
    if (sf_envi_turn_forcer_trig_periodic != null) {
        TriggerStop(sf_envi_turn_forcer_trig_periodic);
        if (sf_envi_turn_forcer_trig_periodic != null) {
            TriggerDestroy(sf_envi_turn_forcer_trig_periodic);
        }
        sf_envi_turn_forcer_trig_periodic = null;
    }
}

void sf_envi_turn_forcer_init()
{
    sf_envi_object_type_t obj_type;

    obj_type.name = "turn_forcer";
    obj_type.fn_destroy = sf_envi_turn_forcer_on_destroy;
    sf_envi_object_register_type_at(obj_type, SF_ENVI_OBJECT_TYPE_TURN_FORCER);
}

int sf_envi_turn_forcer_create(string unit_name, point pos)
{
    int obj_id;
    structref<sf_envi_turn_forcer_t> tufr;
    fixed radius;

    obj_id = sf_envi_object_create_main_at(SF_ENVI_OBJECT_TYPE_TURN_FORCER, unit_name, pos);
    tufr = sf_envi_turn_forcers[obj_id];

    radius = UnitGetPropertyFixed(sf_envi_object_instances[obj_id].main_unit, c_unitPropRadius, true);
    tufr.degrees_per_second = 360.0 / TURN_SPEED_ICE;

    tufr.trig_range_in = TriggerFind("sf_envi_on_turn_forcer_range_in");
    if (tufr.trig_range_in == null) {
        tufr.trig_range_in = TriggerCreate("sf_envi_on_turn_forcer_range_in");
    }
    TriggerAddEventUnitRange(tufr.trig_range_in, null, sf_envi_object_instances[obj_id].main_unit, radius, true);

    tufr.trig_range_out = TriggerFind("sf_envi_on_turn_forcer_range_out");
    if (tufr.trig_range_out == null) {
        tufr.trig_range_out = TriggerCreate("sf_envi_on_turn_forcer_range_out");
    }
    TriggerAddEventUnitRange(tufr.trig_range_out, null, sf_envi_object_instances[obj_id].main_unit, radius, false);

    return obj_id;
}

void sf_envi_turn_forcer_set_rotation_factor(int obj_id, fixed degrees_per_second)
{
    sf_envi_turn_forcers[obj_id].degrees_per_second = degrees_per_second;
}

void sf_envi_turn_forcer_set_auto_rotate(int obj_id, int auto_rotate)
{
    sf_envi_turn_forcers[obj_id].auto_rotate = auto_rotate;

    if (auto_rotate == 0) {
        UnitGroupRemove(sf_envi_turn_forcer_automated_group, sf_envi_object_instances[obj_id].main_unit);
    }
    else {
        UnitGroupAdd(sf_envi_turn_forcer_automated_group, sf_envi_object_instances[obj_id].main_unit);
    }

    if (sf_envi_turn_forcer_trig_periodic == null) {
        sf_envi_turn_forcer_trig_periodic = TriggerCreate("sf_envi_on_turn_forcer_periodic");
        TriggerExecute(sf_envi_turn_forcer_trig_periodic, false, false);
    }
}

void sf_envi_turn_forcer_rotate(int obj_id, fixed angle, bool relative, bool wait_until_done)
{
    structref<sf_envi_turn_forcer_t> tufr;
    int steps;
    fixed angle_total;
    fixed value_per_step;
    int i;

    tufr = sf_envi_turn_forcers[obj_id];

    if (relative) {
        angle_total = angle;
    }
    else {
        angle_total = angle - UnitGetFacing(sf_envi_object_instances[obj_id].main_unit);
    }

    steps = AbsI(FixedToInt(angle_total / tufr.degrees_per_second * (1.0 / TICK_PERIOD)));
    value_per_step = angle_total / IntToFixed(steps);

    if (steps == 0) { return; }

    // Dbg("[TF/Rotate] Steps = " + IntToString(steps));
    // Dbg("[TF/Rotate] Value per step = " + FixedToString(value_per_step, 2));

    // steps = FixedToInt(time / TICK_PERIOD);
    // value_per_step = angle / IntToFixed(steps);

    UnitGroupAdd(sf_envi_turn_forcer_automated_group, sf_envi_object_instances[obj_id].main_unit);
    tufr.value_per_step = value_per_step;
    tufr.steps_left = steps;

    if (sf_envi_turn_forcer_trig_periodic == null) {
        sf_envi_turn_forcer_trig_periodic = TriggerCreate("sf_envi_on_turn_forcer_periodic");
        TriggerExecute(sf_envi_turn_forcer_trig_periodic, false, false);
    }

    while (wait_until_done && tufr.value_per_step > 0) {
        Wait(TICK_PERIOD, c_timeGame);
    }

    // if (wait_until_done) {
    //     for (i = 0; i < steps; i += 1) {
    //         Wait(TICK_PERIOD, c_timeGame);
    //     }
    // }

    // for (i = 0; i < steps; i += 1) {
    //     UnitSetFacing(
    //         sf_envi_object_instances[obj_id].main_unit,
    //         UnitGetFacing(sf_envi_object_instances[obj_id].main_unit) + value_per_step,
    //         TICK_PERIOD
    //     );
    //     Wait(TICK_PERIOD, c_timeGame);
    // }
}

bool sf_envi_on_turn_forcer_range_in(bool test_conds, bool run_actions)
{
    return sf_envi_turn_forcer_process_range(EventUnit(), EventUnitRangeUnit(), true);
}

bool sf_envi_on_turn_forcer_range_out(bool test_conds, bool run_actions)
{
    return sf_envi_turn_forcer_process_range(EventUnit(), EventUnitRangeUnit(), false);
}

bool sf_envi_on_turn_forcer_periodic(bool test_conds, bool run_actions)
{
    int i;
    int count;
    int obj_id;
    unit tmp_unit;
    structref<sf_envi_turn_forcer_t> tufr;
    fixed new_angle;

    for (;;) {
        count = UnitGroupCount(sf_envi_turn_forcer_automated_group, c_unitCountAll);

        if (count <= 0) {
            break;
        }

        for (i = 1; i <= count; i += 1) {
            tmp_unit = UnitGroupUnit(sf_envi_turn_forcer_automated_group, i);
            obj_id = sf_envi_object_get_by_unit(tmp_unit);
            tufr = sf_envi_turn_forcers[obj_id];
            if (tufr.auto_rotate) {
                new_angle = UnitGetFacing(tmp_unit) + (IntToFixed(tufr.auto_rotate) * tufr.degrees_per_second / (1.0 / TICK_PERIOD));
                // Dbg("[Turn Forcer] Obj id: " + IntToString(obj_id));
                // Dbg("[Turn Forcer] Degrees per second: " + FixedToString(tufr.degrees_per_second, 0));
                // Dbg("[Turn Forcer] Auto flag: " + FixedToString(IntToFixed(tufr.auto_rotate), 0));
                // Dbg("[Turn Forcer] Current angle: " + FixedToString(UnitGetFacing(tmp_unit), 0));
                // Dbg("[Turn Forcer] New angle: " + FixedToString(new_angle, 0));
            }
            else if (tufr.steps_left > 0) {
                new_angle = UnitGetFacing(tmp_unit) + tufr.value_per_step;
                UnitSetFacing(tmp_unit, new_angle, TICK_PERIOD);
                tufr.steps_left -= 1;
                if (tufr.steps_left <= 0) {
                    UnitGroupRemove(sf_envi_turn_forcer_automated_group, tmp_unit);
                }
            }
            UnitSetFacing(tmp_unit, new_angle, TICK_PERIOD);
        }

        Wait(TICK_PERIOD, c_timeGame);
    }

    TriggerDestroy(TriggerGetCurrent());
    sf_envi_turn_forcer_trig_periodic = null;

    return true;
}
