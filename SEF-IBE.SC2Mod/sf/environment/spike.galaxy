struct sf_envi_spike_t {
    fixed size;
    region rg;
    bool just_created;
};

sf_envi_spike_t [SF_ENVI_OBJECT_INSTANCE_LIMIT]sf_envi_spikes;
trigger sf_envi_trig_spikes_watch = null;
unitgroup sf_envi_spikes_ugroup = UnitGroupEmpty();
bool[MAX_PLAYERS + 1] sf_envi_spikes_check_flag;

static void sf_envi_spike_on_destroy(int obj_id)
{
    if (UnitGroupCount(sf_envi_spikes_ugroup, c_unitCountAll) <= 1 && sf_envi_trig_spikes_watch != null) {
        TriggerStop(sf_envi_trig_spikes_watch);
        TriggerDestroy(sf_envi_trig_spikes_watch);
        sf_envi_trig_spikes_watch = null;
    }

    UnitGroupRemove(sf_envi_spikes_ugroup, sf_envi_object_instances[obj_id].main_unit);
}

static unitgroup sf_envi_spike_do_check(int obj_id)
{
    unit munit;
    unitgroup affected_group;
    int i;
    unit tmp_unit;
    unitgroup deadgroup = UnitGroupEmpty();

    munit = sf_envi_object_instances[obj_id].main_unit;

    if (UnitGetHeight(munit) > -0.9) {
        affected_group = UnitGroup(null, c_playerAny, sf_envi_spikes[obj_id].rg, UnitFilter((1 << c_targetFilterBiological), 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32)) | (1 << (c_targetFilterInvulnerable - 32))), c_noMaxCount);

        for (i = 1; i <= UnitGroupCount(affected_group, c_unitCountAll); i += 1) {
            tmp_unit = UnitGroupUnit(affected_group, i);
            if (sf_phys_is_unit_during_jump(tmp_unit)) { continue; }
            UnitGroupAdd(deadgroup, tmp_unit);
        }
    }

    return deadgroup;
}

void sf_envi_spike_init()
{
    sf_envi_object_type_t obj_type;

    obj_type.name = "spike";
    obj_type.fn_destroy = sf_envi_spike_on_destroy;
    sf_envi_object_register_type_at(obj_type, SF_ENVI_OBJECT_TYPE_SPIKE);
}

int sf_envi_spike_create(string unit_name, point pos, fixed size)
{
    int obj_id;
    fixed scale;

    obj_id = sf_envi_object_create_main_at(SF_ENVI_OBJECT_TYPE_SPIKE, unit_name, pos);
    // sf_phys_collider_track(sf_envi_object_instances[obj_id].main_unit, CL_TYPE_KILLER, SF_PHYS_COLLIDER_SHAPE_SQUARE, size, size);
    scale = ((size / 1.5) * 0.375);
    ActorSend(libNtve_gf_MainActorofUnit(UnitLastCreated()), libNtve_gf_SetScale(scale, scale, 0.6, 0.0));
    // UnitSetHeight(sf_envi_object_instances[obj_id].main_unit, -1.3, 0);
    UnitSetState(sf_envi_object_instances[obj_id].main_unit, c_unitStateInvulnerable, true);

    sf_envi_spikes[obj_id].just_created = true;
    sf_envi_spikes[obj_id].size = size;
    sf_envi_spikes[obj_id].rg = RegionRect(0, 0, size, size);
    RegionSetCenter(sf_envi_spikes[obj_id].rg, UnitGetPosition(sf_envi_object_instances[obj_id].main_unit));

    UnitGroupAdd(sf_envi_spikes_ugroup, sf_envi_object_instances[obj_id].main_unit);

    if (sf_envi_trig_spikes_watch == null) {
        sf_envi_trig_spikes_watch = TriggerCreate("sf_envi_on_spike_periodic");
        TriggerExecute(sf_envi_trig_spikes_watch, false, false);
    }

    return obj_id;
}

void sf_envi_spike_raise(int obj_id, bool raise)
{
    unit munit;

    munit = sf_envi_object_instances[obj_id].main_unit;

    if (raise) {
        if (UnitGetHeight(munit) < -0.35) {
            if (!sf_envi_spikes[obj_id].just_created) {
                SoundPlayAtPoint(SoundLink("spikesRaise", -1), PlayerGroupAll(), UnitGetPosition(munit), 0.0, 190.0, 0.0);
            }
            sf_envi_spikes[obj_id].just_created = false;
            UnitSetHeight(munit, -0.3, 0.25);
        }
    }
    else {
        if (UnitGetHeight(munit) > -1.05) {
            if (!sf_envi_spikes[obj_id].just_created) {
                SoundPlayAtPoint(SoundLink("spikesLower", -1), PlayerGroupAll(), UnitGetPosition(munit), 0.0, 150.0, 0.0);
            }
            sf_envi_spikes[obj_id].just_created = false;
            UnitSetHeight(munit, -1.1, 0.25);
        }
    }
}

bool sf_envi_spike_is_raised(int obj_id)
{
    unit munit;

    munit = sf_envi_object_instances[obj_id].main_unit;

    if (UnitGetHeight(munit) > -1.05) {
        return true;
    }
    else {
        return false;
    }
}

bool sf_envi_on_spike_periodic(bool test_conds, bool run_actions)
{
    int i;
    unit tmp_unit;
    unitgroup deadgroup = UnitGroupEmpty();

    for (;;) {
        UnitGroupClear(deadgroup);

        for (i = 1; i <= UnitGroupCount(sf_envi_spikes_ugroup, c_unitCountAll); i += 1) {
            tmp_unit = UnitGroupUnit(sf_envi_spikes_ugroup, i);
            UnitGroupAddUnitGroup(
                deadgroup,
                sf_envi_spike_do_check(sf_envi_object_get_by_unit(tmp_unit))
            );
        }

        // reset check flag for unafacted heroes
        for (i = 1; i <= UnitGroupCount(sf_game_hero_get_unitgroup(), c_unitCountAlive); i += 1) {
            tmp_unit = UnitGroupUnit(sf_game_hero_get_unitgroup(), i);
            if (UnitGroupHasUnit(deadgroup, tmp_unit)) { continue; }
            sf_envi_spikes_check_flag[UnitGetOwner(tmp_unit)] = false;
        }

        for (i = 1; i <= UnitGroupCount(deadgroup, c_unitCountAll); i += 1) {
            tmp_unit = UnitGroupUnit(deadgroup, i);
            if (!sf_envi_spikes_check_flag[UnitGetOwner(tmp_unit)]) {
                sf_envi_spikes_check_flag[UnitGetOwner(tmp_unit)] = true;
                continue;
            }
            UnitKill(tmp_unit);
        }
        Wait(TICK_PERIOD, c_timeGame);
    }

    return true;
}
