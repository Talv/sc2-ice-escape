static int gm_heroReleasePlayer;
bool gm_onReleaseHero(bool testConds, bool runActions) {
    int playerId;
    structref<HERO> hero;

    playerId = gm_heroReleasePlayer;
    hero = gm_players[playerId].hero;

    libNtve_gf_CreateModelWithPointFacing("HybridWarpInEffect", libNtve_gf_PointFromPositionAndAngle(libNtve_gf_PointWithZOffset(UnitGetPosition(hero.mainUnit), 0.0), UnitGetFacing(hero.mainUnit)));
    libNtve_gf_PlayAnimation(libNtve_gf_ActorLastCreated(), c_animNameDefault, "Stand", 0, c_animTimeDefault);
    SoundPlayAtPoint(SoundLink("Hybrid_WarpIn", -1), PlayerGroupAll(), UnitGetPosition(hero.mainUnit), 2.5, 25.0, 0.0);
    ActorSend(libNtve_gf_ActorLastCreated(), "SetOpacity 0.000000 1.475000");

    Wait(0.5, c_timeReal);

    hero.paused = false;
    UnitSetState(hero.mainUnit, c_unitStateInvulnerable, false);

    TriggerDestroy(TriggerGetCurrent());
    return true;
}

void gm_setHeroPosition(structref<HERO> hero, point position, fixed facing, int reason) {
    bool revived;

    hero.supress_turn = false;

    if (!UnitIsValid(hero.mainUnit)) {
        UnitCreate(1, "IceBaneling", c_unitCreateIgnorePlacement, hero.player, position, facing);
        UnitControlGroupAddUnits(hero.player, 1, UnitLastCreatedGroup());
        hero.mainUnit = UnitLastCreated();
        UnitGroupAdd(gm_herogroup, hero.mainUnit);
        UnitSetPropertyFixed(hero.mainUnit, c_unitPropLevel, 1.0);
        UnitSetPropertyFixed(hero.mainUnit, c_unitPropLife, 100.0);
        UnitSetPropertyFixed(hero.mainUnit, c_unitPropEnergy, 100.0);
        UnitAbilityShow(hero.mainUnit, "ShadeUse", false);
        // UnitAbilityShow(hero.mainUnit, "ARTSwitch", false);
        UnitAbilityShow(hero.mainUnit, "Switch", false);

        if (GameIsTestMap(false)) {
            UnitSetPropertyFixed(
                hero.mainUnit,
                c_unitPropLevel,
                20
            );
        }

        UnitClearSelection(UnitGetOwner(hero.mainUnit));
        UnitSelect(hero.mainUnit, UnitGetOwner(hero.mainUnit), true);

        TriggerAddEventUnitDied(hr_allocateTrigger(hero, "gm_onHeroDeath", false), UnitRefFromUnit(hero.mainUnit));
    }
    if (!UnitIsValid(hero.guideUnit)) {
        UnitCreate(1, "IceBaneling2", c_unitCreateIgnorePlacement, hero.player, position, facing);
        hero.guideUnit = UnitLastCreated();
        UnitSetState(UnitLastCreated(), c_unitStateSelectable, false);
        UnitSetState(UnitLastCreated(), c_unitStateRadarable, false);
        UnitSetState(UnitLastCreated(), c_unitStateInvulnerable, true);
        libNtve_gf_SendActorMessageToUnit(hero.guideUnit, libNtve_gf_ModelSwap("Invisible", 1));
        libNtve_gf_SendActorMessageToUnit(hero.guideUnit, "SetMinimapVisibility 0");
    }

    if (!UnitIsAlive(hero.mainUnit)) {
        UnitRevive(hero.mainUnit);
        UnitSetPropertyFixed(hero.mainUnit, c_unitPropLife, 50.0);
        UnitSetPropertyFixed(hero.mainUnit, c_unitPropEnergy, 50.0);
        revived = true;
    }

    if (UnitIsValid(hero.corpseUnit)) {
        cl_unregisterUnit(hero.corpseUnit);
        UnitRemove(hero.corpseUnit);
        hero.corpseUnit = null;
    }

    if (UnitIsValid(hero.shadeUnit) && reason == HERO_POSITION_CHANGE_REASON_NEW_MAP) {
        sf_game_abil_shade_remove(hero.shadeUnit);
        hero.shadeUnit = null;
    }

    hero.surfaceType = sd_getSurfaceAt(position);
    UnitSetPosition(hero.mainUnit, position, false);
    UnitSetPosition(hero.guideUnit, position, false);
    hero.desiredAngle = facing;
    UnitSetFacing(hero.guideUnit, facing, 0);
    if (hero.surfaceType == SURFACE_REVERSE_ICE) {
        UnitSetFacing(hero.mainUnit, facing + 180.0, 0);
    }
    else if (hero.surfaceType == SURFACE_90DEG_ICE) {
        UnitSetFacing(hero.mainUnit, facing + 90.0, 0);
    }
    else {
        UnitSetFacing(hero.mainUnit, facing, 0);
    }

    if (hero.surfaceType == SURFACE_REVERSE_GROUND) {
        libNtve_gf_SendActorMessageToUnit(hero.mainUnit, "HostSiteOpsSet ::Host SOp180");
    }
    else {
        libNtve_gf_SendActorMessageToUnit(hero.mainUnit, "HostSiteOpsSet ::Host");
    }

    UnitIssueOrder(hero.mainUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);
    UnitIssueOrder(hero.guideUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);

    if (revived) {
        Wait(0.0, c_timeGame);

        if (reason == HERO_POSITION_CHANGE_REASON_REVIVE) {
            hero.paused = true;
            UnitSetState(hero.mainUnit, c_unitStateInvulnerable, true);

            gm_heroReleasePlayer = UnitGetOwner(hero.mainUnit);
            TriggerExecute(TriggerCreate("gm_onReleaseHero"), true, false);
        }

        sf_core_event_prepare("hero_revive");
        sf_core_event_set_int("player", UnitGetOwner(hero.mainUnit));
        sf_core_event_set_int("reason", reason);
        sf_core_event_send();
    }
}

int gm_getPlayerByUnit(unit fromUnit) {
    int i;

    for (i = 1; i <= MAX_PLAYERS; i += 1) {
        if (UnitIsValid(gm_players[i].hero.mainUnit) && gm_players[i].hero.mainUnit == fromUnit) {
            return i;
        }
    }
    return -1;
}

void gm_kill_hero(structref<HERO> hero) {
    UnitKill(hero.mainUnit);
}

void gm_spawnHero(structref<HERO> hero, int reason) {
    if (hero.paused) {
        hero.paused = false;
        UnitSetState(hero.mainUnit, c_unitStateHidden, false);
        UnitSetState(hero.mainUnit, c_unitStateInvulnerable, false);
    }

    gm_setHeroPosition(
        hero,
        RegionRandomPoint(lv_spawnRegion),
        RandomFixed(-180.0, 180.0),
        reason
    );

    sf_core_event_prepare("sf_hero_spawn");
    sf_core_event_set_int("player", hero.player);
    sf_core_event_set_unit("hero_unit", hero.mainUnit);
    sf_core_event_send();
}

void sf_game_add_event_hero_spawn(trigger trig)
{
    sf_core_event_attach(trig, "sf_hero_spawn");
}

// new:

static void hr_cleanHeroTriggers(structref<HERO> hero) {
    int i;

    for (i = 0; i < HERO_MAX_TRIGGERS; i += 1) {
        if (!TriggerExists(hero.attachedTriggers[i])) { continue; }
        TriggerStop(hero.attachedTriggers[i]);
        TriggerDestroy(hero.attachedTriggers[i]);
        hero.attachedTriggers[i] = null;
    }
}


static trigger hr_getHeroTrigger(structref<HERO> hero, string funcName) {
    int i;

    for (i = 0; i < HERO_MAX_TRIGGERS; i += 1) {
        if (!TriggerExists(hero.attachedTriggers[i])) { continue; }
        if (!StringEqual( TriggerGetFunction(hero.attachedTriggers[i]), funcName, true )) { continue; }

        return hero.attachedTriggers[i];
    }

    return null;
}


//
// PUBLIC
//

void hr_registerTrigger(structref<HERO> hero, trigger trig) {
    int i;

    for (i = 0; i < HERO_MAX_TRIGGERS; i += 1) {
        if (TriggerExists(hero.attachedTriggers[i])) { continue; }
        hero.attachedTriggers[i] = trig;
        break;
    }
}

trigger hr_allocateTrigger(structref<HERO> hero, string func, bool levelScoped) {
    trigger t;

    t = hr_getHeroTrigger(hero, func);
    if (t == null) {
        t = TriggerCreate(func);
        hr_registerTrigger(hero, t);
        if (levelScoped) {
            lv_registerTemporaryTrigger(t);
        }
    }

    return t;
}

int hr_getPlayerConnectedToTrigger(trigger trig) {
    int playerIter;
    int playerId;
    int i;

    // @TODO rework to use tData
    for (playerId = 1; playerId <= MAX_PLAYERS; playerId += 1) {
        if (!gm_players[playerId].active) { continue; }
        for (i = 0; i < HERO_MAX_TRIGGERS; i += 1) {
            if (!TriggerExists(gm_players[playerId].hero.attachedTriggers[i])) { break; }
            if (trig == gm_players[playerId].hero.attachedTriggers[i]) {
                return playerId;
            }
        }
    }

    return -1;
}

void hr_cleanTriggersAll() {
    int i;

    for (i = 1; i < UnitGroupCount(gm_herogroup, c_unitCountAll); i += 1) {
        hr_cleanHeroTriggers( gm_players[UnitGetOwner(UnitGroupUnit(gm_herogroup, i))].hero );
    }
}

void hr_clearSlot(structref<HERO> hero) {
    hr_cleanHeroTriggers(hero);
    if (UnitIsValid(hero.mainUnit)) {
        UnitRemove(hero.mainUnit);
        hero.mainUnit = null;
    }
    if (UnitIsValid(hero.guideUnit)) {
        UnitRemove(hero.guideUnit);
        hero.guideUnit = null;
    }
    if (UnitIsValid(hero.shadeUnit)) {
        UnitRemove(hero.shadeUnit);
        hero.shadeUnit = null;
    }
    if (UnitIsValid(hero.corpseUnit)) {
        UnitRemove(hero.corpseUnit);
        hero.corpseUnit = null;
    }
}


void hr_revive(int revivingPlayer, structref<HERO> hero, bool spawnHero) {
    if (spawnHero) {
        gm_spawnHero(hero, HERO_POSITION_CHANGE_REASON_REVIVE);
    }

    if (revivingPlayer != -1) {
        sf_stat_session_stats[revivingPlayer].revives += 1;
        sf_stat_session_expire(revivingPlayer);
    }
}

void sf_hero_revive(unit hero_unit, int reviving_player)
{
    hr_revive(reviving_player, gm_players[UnitGetOwner(hero_unit)].hero, true);
}

//
// API
//

// fixed HeroGetSpeed() {
//     return 4.6;
// }

// unitgroup HeroGetGroup() {
//     // clone it?
//     return gm_herogroup;
// }

// OBSOLETE
// int EventHero() {
//     return EventHeroPlayer();
// }

int EventHeroPlayer() {
    return hr_getPlayerConnectedToTrigger(TriggerGetCurrent());
}

unit sf_game_hero_get_unit(int playerId) {
    return gm_players[playerId].hero.mainUnit;
}

unitgroup sf_game_hero_get_unitgroup() {
    return UnitGroupCopy(gm_herogroup);
}

// void HeroAttachTriggerEntersRegion(trigger trig, region rg, bool enters) {
//     int i;
//     structref<HERO> hero;

//     for (i = 1; i <= UnitGroupCount(gm_herogroup, c_unitCountAll); i+= 1) {
//         hero = gm_players[gm_getPlayerByUnit(UnitGroupUnit(gm_herogroup, i))].hero;
//         TriggerAddEventUnitRegion(
//             hr_allocateTrigger(hero, TriggerGetFunction(trig), true),
//             UnitRefFromUnit(hero.mainUnit),
//             rg,
//             enters
//         );
//     }
// }

void sf_game_hero_grant_powerup(unit munit)
{
    PlayerCreateEffectUnit(0, "Feedback", munit);
    // UnitBehaviorAdd(munit, "LevelUpDummyBehavior", munit, 1);
    UnitSetPropertyFixed(
        munit,
        c_unitPropLevel,
        UnitGetPropertyFixed(munit, c_unitPropLevel, c_unitPropCurrent) + 1.0
    );
}
