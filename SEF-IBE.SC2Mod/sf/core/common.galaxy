
//

string sf_point_to_string(point p)
{
    return "(X: " + FixedToString(PointGetX(p), 4) + " Y:" + FixedToString(PointGetY(p), 4) + ")";
}

bool sf_is_numeric(string s)
{
    int i;
    int l;
    bool is_num;
    string tmp_word;

    for (i = 1; i <= StringLength(s); i += 1) {
        tmp_word = StringSub(s, i, i);
        for (l = 0; l <= 9; l += 1) {
            if (!StringEqual(tmp_word, IntToString(l), true)) { continue; }
            is_num = true;
            break;
        }
        if (!is_num) {
            return false;
        }
    }

    return true;
}

string string_fill(string character, int length) {
    string str;
    int i;

    for (i = 1; i <= length; i += 1) {
        str += character;
    }

    return str;
}

string sf_string_width_space(string str, int width)
{
    if (StringLength(str) < width) {
        str = string_fill(" ", width - StringLength(str)) + str;
    }
    return str;
}

text sf_format_time(fixed time)
{
    text txt;

    if (time >= 3600.0) {
        txt += TextTimeFormat(
            StringToText("<hour/>h "),
            FixedToInt(time)
        );
    }
    if (time >= 60.0) {
        txt += TextTimeFormat(
            StringToText("<min/>m "),
            FixedToInt(time)
        );
    }
    txt += TextTimeFormat(
        StringToText("<sec2/>"),
        FixedToInt(time)
    );

    if (time <= 3600.0) {
        txt += StringToText(".") + StringToText(StringSub(
            FixedToString(time - IntToFixed(FixedToInt(time)), 2),
            3,
            5
        ));
    }

    txt += StringToText("s");

    return txt;
}

text sf_player_name_colored(int player)
{
    color col;
    text name;

    if (PlayerType(player) == c_playerTypeNone) {
        name = StringToText("Unkown Player " + IntToString(player));
    }
    else {
        name = PlayerName(player);
    }

    return TextWithColor(name, libNtve_gf_ConvertPlayerColorToColor(PlayerGetColorIndex(player, false)));
}

bool sf_int_to_bool(int val)
{
    if (val == 0) {
        return false;
    }
    else {
        return true;
    }
}

void sf_make_unit_selectable(unit munit, bool selectable)
{
    UnitSetState(munit, c_unitStateHighlightable, selectable);
    UnitSetState(munit, c_unitStateSelectable, selectable);
    UnitSetState(munit, c_unitStateTooltipable, selectable);
    UnitSetState(munit, c_unitStateTargetable, selectable);
}

void DbgAtPoint(point pt, string txt) {
    TextTagCreate(StringToText(txt), 24, pt, 1.0, true, false, PlayerGroupAll());
    TextTagSetTime(
        TextTagLastCreated(),
        c_textTagTimeDuration,
        4.0
    );
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextStart, Color(100.00, 0.00, 0.00));
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextEnd, Color(100.00, 100.00, 100.00));
    TextTagSetFontSize(TextTagLastCreated(), 24);
}

void DbgAtUnit(unit cUnit, string txt) {
    TextTagCreate(StringToText(txt), 24, UnitGetPosition(cUnit), 1.0, true, false, PlayerGroupAll());
    TextTagSetTime(
        TextTagLastCreated(),
        c_textTagTimeDuration,
        4.0
    );
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextStart, Color(100.00, 0.00, 0.00));
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextEnd, Color(100.00, 100.00, 100.00));
    TextTagSetFontSize(TextTagLastCreated(), 24);
    TextTagAttachToUnit(TextTagLastCreated(), cUnit, 1.5);
}

void DbgText(text msg) {
    TriggerDebugOutput(1, msg, false);
}

void Dbg(string msg) {
    msg = "[" + FixedToString(GameGetMissionTime(), 2) + "] " + msg;
    DbgText(StringToText(msg));
}

void DbgPt(point p) {
    Dbg("X: " + FixedToString(PointGetX(p), -1) + " Y:" + FixedToString(PointGetY(p), -1));
}

void DbgFx(fixed f) {
    Dbg("F: " + FixedToString(f, -1));
}

//

void print_t(text msg) {
    UIDisplayMessage(PlayerGroupActive(), c_messageAreaSubtitle, StringToText("DEBUG: ") + msg);
}

void print(string msg) {
    print_t(StringToText(msg));
}

void print_i(int i) {
    print("I: " + IntToString(i));
}
void print_b(bool b) {
    print("B: " + IntToString(BoolToInt(b)));
}
void print_f(fixed i) {
    print("F: " + FixedToString(i, -1));
}
void print_p(point p) {
    print("X: " + FixedToString(PointGetX(p), -1) + " Y:" + FixedToString(PointGetY(p), -1));
}

bool TriggerExists(trigger trig) {
    if (trig == null) {
        return false;
    }
    if (TriggerGetFunction(trig)) {
        return true;
    }
    return false;
}

int sf_bool_to_int(bool b)
{
    if (b) {
        return 1;
    }
    else {
        return 0;
    }
}

int string_find_last(string s1, string s2, bool case_sens)
{
    int i;
    int l;
    int offset;
    int s1_len;
    int s2_len;

    s1_len = StringLength(s1);
    s2_len = StringLength(s2);

    // Dbg("[sfind/last] s1 = '" + s1 + "' s2 = '" + s2 + "'");

    for (i = s1_len; i >= s2_len; i -= 1) {
        for (l = s2_len; l >= 1; l -= 1) {
            offset = i + (l - s2_len);
            // Dbg("[sfind/last] offset = " + IntToString(offset) + " c1 = '" + StringSub(s1, offset, offset) + "' c2 = '" + StringSub(s2, l, l) + "'");
            if (StringCompare(StringSub(s1, offset, offset), StringSub(s2, l, l), case_sens) != 0) { break; }
            // if (StringSub(s1, offset, offset) != StringSub(s2, l, l)) { break; }
            if (l == 1) {
                return offset;
            }
        }
    }

    return c_stringNotFound;
}


void sf_core_logger_setup() {
    int i;
    string phandle;

    TriggerDebugSetTypeFile(1, "SEF");
    Dbg("Game reset");
    // for (i = 1; i < c_maxPlayers; i += 1) {
    //     if (PlayerStatus(i) == 0) {
    //         continue;
    //     }
    //     if (!GameIsTestMap(false)) {
    //         phandle = PlayerHandle(i);
    //     }
    //     DbgText(
    //         StringToText("Player ") + IntToText(i) +
    //         StringToText(": ") + StringToText(phandle) +
    //         StringToText(" - ") + PlayerName(i)
    //     );
    // }
}

//

const string libWH_GVC_BAS_NameTempAttachActor = "LibWH_Actor_CommonBeamAttachedActor";
const string libWH_GVC_BAS_NameTempAttachModel = "LibWH_Actor_CommonBeamAttachedInvisibleModel";
actorscope libWH_GVC_BAS_CommonActorscope = ActorScopeCreate("LibWH_Actor_CommonBeamEmptyScope");
actor LibWH_FUNC_BS_BeamCreateActorToActor(string lp_ActorType, string lp_ModelLink, actor lp_FromActor, string lp_FromActorAttachment, actor lp_ToActor, string lp_ToActorAttachment)
{
    actor lv_FromActor;
    actor lv_ToActor;
    actor lv_Beam;
    string lv_FromAttachment;
    string lv_ToAttachment;
    lv_FromAttachment = "{" + lp_FromActorAttachment + "}";
    lv_ToAttachment = "{" + lp_ToActorAttachment + "}";
    ActorSend(lp_FromActor, "AttachModel " + libWH_GVC_BAS_NameTempAttachActor + " " + libWH_GVC_BAS_NameTempAttachModel + " " + lv_FromAttachment);
    lv_FromActor = ActorFromScope(libWH_GVC_BAS_CommonActorscope, "::LastCreatedActual");
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamFrom", lv_FromActor);
    ActorSend(lp_ToActor, "AttachModel " + libWH_GVC_BAS_NameTempAttachActor + " " + libWH_GVC_BAS_NameTempAttachModel + " " + lv_ToAttachment);
    lv_ToActor = ActorFromScope(libWH_GVC_BAS_CommonActorscope, "::LastCreatedActual");
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamTo", lv_ToActor);
    lv_Beam = ActorCreate(libWH_GVC_BAS_CommonActorscope, lp_ActorType, lp_ModelLink, "::scope.BeamFrom","::scope.BeamTo");
    ActorRefSet(lv_Beam, "::actor.BeamFrom", lv_FromActor);
    ActorRefSet(lv_Beam, "::actor.BeamTo", lv_ToActor);
    return lv_Beam;
}
actor LibWH_FUNC_BS_BeamCreate(string lp_ActorType, string lp_ModelLink, actor lp_FromActor, actor lp_ToActor)
{
    actor lv_Beam;
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamFrom", lp_FromActor);
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamTo", lp_ToActor);
    lv_Beam = ActorCreate(libWH_GVC_BAS_CommonActorscope, lp_ActorType, lp_ModelLink, "::scope.BeamFrom","::scope.BeamTo");
    ActorRefSet(lv_Beam, "::actor.BeamFrom", lp_FromActor);
    ActorRefSet(lv_Beam, "::actor.BeamTo", lp_ToActor);
    return lv_Beam;
}
actor LibWH_FUNC_BS_CreateBeamPointAtActor(actor lp_Actor, string lp_Attachment)
{
    string lv_Attachment;
    lv_Attachment = "{" + lp_Attachment + "}";
    ActorSend(lp_Actor, "AttachModel " + libWH_GVC_BAS_NameTempAttachActor + " " + libWH_GVC_BAS_NameTempAttachModel + " " + lv_Attachment);
    return ActorFromScope(libWH_GVC_BAS_CommonActorscope, "::LastCreatedActual");
}
