
//

string sf_point_to_string(point p)
{
    return "(X: " + FixedToString(PointGetX(p), 4) + " Y:" + FixedToString(PointGetY(p), 4) + ")";
}

bool sf_is_numeric(string s)
{
    int i;
    int l;
    bool is_num;
    string tmp_word;

    for (i = 1; i <= StringLength(s); i += 1) {
        tmp_word = StringSub(s, i, i);
        for (l = 0; l <= 9; l += 1) {
            if (!StringEqual(tmp_word, IntToString(l), true)) { continue; }
            is_num = true;
            break;
        }
        if (!is_num) {
            return false;
        }
    }

    return true;
}

string string_fill(string character, int length) {
    string str;
    int i;

    for (i = 1; i <= length; i += 1) {
        str += character;
    }

    return str;
}

string sf_string_width_space(string str, int width)
{
    if (StringLength(str) < width) {
        str = string_fill(" ", width - StringLength(str)) + str;
    }
    return str;
}

text sf_player_name_colored(int player)
{
    color col;
    text name;

    if (PlayerType(player) == c_playerTypeNone) {
        name = StringToText("Unkown Player " + IntToString(player));
    }
    else {
        name = PlayerName(player);
    }

    return TextWithColor(name, libNtve_gf_ConvertPlayerColorToColor(PlayerGetColorIndex(player, false)));
}

bool sf_int_to_bool(int val)
{
    if (val == 0) {
        return false;
    }
    else {
        return true;
    }
}

void sf_make_unit_selectable(unit munit, bool selectable)
{
    UnitSetState(munit, c_unitStateHighlightable, selectable);
    UnitSetState(munit, c_unitStateSelectable, selectable);
    UnitSetState(munit, c_unitStateTooltipable, selectable);
    UnitSetState(munit, c_unitStateTargetable, selectable);
}

void DbgAtPoint(point pt, string txt) {
    TextTagCreate(StringToText(txt), 24, pt, 1.0, true, false, PlayerGroupAll());
    TextTagSetTime(
        TextTagLastCreated(),
        c_textTagTimeDuration,
        4.0
    );
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextStart, Color(100.00, 0.00, 0.00));
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextEnd, Color(100.00, 100.00, 100.00));
    TextTagSetFontSize(TextTagLastCreated(), 24);
}

void DbgAtUnit(unit cUnit, string txt) {
    TextTagCreate(StringToText(txt), 24, UnitGetPosition(cUnit), 1.0, true, false, PlayerGroupAll());
    TextTagSetTime(
        TextTagLastCreated(),
        c_textTagTimeDuration,
        4.0
    );
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextStart, Color(100.00, 0.00, 0.00));
    TextTagSetColor(TextTagLastCreated(), c_textTagColorTextEnd, Color(100.00, 100.00, 100.00));
    TextTagSetFontSize(TextTagLastCreated(), 24);
    TextTagAttachToUnit(TextTagLastCreated(), cUnit, 1.5);
}

void DbgText(text msg) {
    TriggerDebugOutput(1, msg, false);
}

void Dbg(string msg) {
    msg = "[" + FixedToString(GameGetMissionTime(), 2) + "] " + msg;
    DbgText(StringToText(msg));
}

void DbgPt(point p) {
    Dbg("X: " + FixedToString(PointGetX(p), -1) + " Y:" + FixedToString(PointGetY(p), -1));
}

void DbgFx(fixed f) {
    Dbg("F: " + FixedToString(f, -1));
}

//

void print_t(text msg) {
    UIDisplayMessage(PlayerGroupActive(), c_messageAreaSubtitle, StringToText("DEBUG: ") + msg);
}

void print(string msg) {
    print_t(StringToText(msg));
}

void print_i(int i) {
    print("I: " + IntToString(i));
}
void print_b(bool b) {
    print("B: " + IntToString(BoolToInt(b)));
}
void print_f(fixed i) {
    print("F: " + FixedToString(i, -1));
}
void print_p(point p) {
    print("X: " + FixedToString(PointGetX(p), -1) + " Y:" + FixedToString(PointGetY(p), -1));
}

bool TriggerExists(trigger trig) {
    if (trig == null) {
        return false;
    }
    if (TriggerGetFunction(trig)) {
        return true;
    }
    return false;
}

int sf_bool_to_int(bool b)
{
    if (b) {
        return 1;
    }
    else {
        return 0;
    }
}


void sf_core_logger_setup() {
    int i;
    string phandle;

    TriggerDebugSetTypeFile(1, "SEF");
    Dbg("Game reset");
    // for (i = 1; i < c_maxPlayers; i += 1) {
    //     if (PlayerStatus(i) == 0) {
    //         continue;
    //     }
    //     if (!GameIsTestMap(false)) {
    //         phandle = PlayerHandle(i);
    //     }
    //     DbgText(
    //         StringToText("Player ") + IntToText(i) +
    //         StringToText(": ") + StringToText(phandle) +
    //         StringToText(" - ") + PlayerName(i)
    //     );
    // }
}

//

const string libWH_GVC_BAS_NameTempAttachActor = "LibWH_Actor_CommonBeamAttachedActor";
const string libWH_GVC_BAS_NameTempAttachModel = "LibWH_Actor_CommonBeamAttachedInvisibleModel";
actorscope libWH_GVC_BAS_CommonActorscope = ActorScopeCreate("LibWH_Actor_CommonBeamEmptyScope");
actor LibWH_FUNC_BS_BeamCreateActorToActor(string lp_ActorType, string lp_ModelLink, actor lp_FromActor, string lp_FromActorAttachment, actor lp_ToActor, string lp_ToActorAttachment)
{
    actor lv_FromActor;
    actor lv_ToActor;
    actor lv_Beam;
    string lv_FromAttachment;
    string lv_ToAttachment;
    lv_FromAttachment = "{" + lp_FromActorAttachment + "}";
    lv_ToAttachment = "{" + lp_ToActorAttachment + "}";
    ActorSend(lp_FromActor, "AttachModel " + libWH_GVC_BAS_NameTempAttachActor + " " + libWH_GVC_BAS_NameTempAttachModel + " " + lv_FromAttachment);
    lv_FromActor = ActorFromScope(libWH_GVC_BAS_CommonActorscope, "::LastCreatedActual");
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamFrom", lv_FromActor);
    ActorSend(lp_ToActor, "AttachModel " + libWH_GVC_BAS_NameTempAttachActor + " " + libWH_GVC_BAS_NameTempAttachModel + " " + lv_ToAttachment);
    lv_ToActor = ActorFromScope(libWH_GVC_BAS_CommonActorscope, "::LastCreatedActual");
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamTo", lv_ToActor);
    lv_Beam = ActorCreate(libWH_GVC_BAS_CommonActorscope, lp_ActorType, lp_ModelLink, "::scope.BeamFrom","::scope.BeamTo");
    ActorRefSet(lv_Beam, "::actor.BeamFrom", lv_FromActor);
    ActorRefSet(lv_Beam, "::actor.BeamTo", lv_ToActor);
    return lv_Beam;
}
actor LibWH_FUNC_BS_BeamCreate(string lp_ActorType, string lp_ModelLink, actor lp_FromActor, actor lp_ToActor)
{
    actor lv_Beam;
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamFrom", lp_FromActor);
    ActorScopeRefSet(libWH_GVC_BAS_CommonActorscope, "::scope.BeamTo", lp_ToActor);
    lv_Beam = ActorCreate(libWH_GVC_BAS_CommonActorscope, lp_ActorType, lp_ModelLink, "::scope.BeamFrom","::scope.BeamTo");
    ActorRefSet(lv_Beam, "::actor.BeamFrom", lp_FromActor);
    ActorRefSet(lv_Beam, "::actor.BeamTo", lp_ToActor);
    return lv_Beam;
}
actor LibWH_FUNC_BS_CreateBeamPointAtActor(actor lp_Actor, string lp_Attachment)
{
    string lv_Attachment;
    lv_Attachment = "{" + lp_Attachment + "}";
    ActorSend(lp_Actor, "AttachModel " + libWH_GVC_BAS_NameTempAttachActor + " " + libWH_GVC_BAS_NameTempAttachModel + " " + lv_Attachment);
    return ActorFromScope(libWH_GVC_BAS_CommonActorscope, "::LastCreatedActual");
}
