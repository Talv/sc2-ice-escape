static bool[MAX_PLAYERS + 1] sf_phys_restrain_next_order;

static int sd_mapTextXY(int x, int y)
{
    return sf_phys_text_surface[
        StringToInt(StringSub(tm[y], x + 1, x + 1))
    ];
}

bool sf_phys_is_ice(int surface, int excludeSurface)
{
    if (
        (
            surface == SURFACE_NORMAL_ICE ||
            surface == SURFACE_REVERSE_ICE ||
            surface == SURFACE_STRAIGHT_ICE ||
            surface == SURFACE_FAST_ICE ||
            surface == SURFACE_REVERSE_FAST_ICE ||
            surface == SURFACE_90DEG_ICE
        ) &&
        surface != excludeSurface
    ) {
        return true;
    }
    else {
        return false;
    }
}

bool sf_phys_is_land(int surface, int excludeSurface) {
    if (
        (
            surface == SURFACE_LAND ||
            surface == SURFACE_REVERSE_GROUND
        ) &&
        surface != excludeSurface
    ) {
        return true;
    }
    else {
        return false;
    }
}

static order sd_makeRevGroundOrder(unit heroUnit, order currentOrder) {
    point currentPoint;
    point targetPoint;

    currentPoint = UnitGetPosition(heroUnit);
    targetPoint = OrderGetTargetPosition(currentOrder);

    return OrderTargetingPoint(
        AbilityCommand("move", 0),
        Point(
            PointGetX(currentPoint) + (PointGetX(currentPoint) - PointGetX(targetPoint)),
            PointGetY(currentPoint) + (PointGetY(currentPoint) - PointGetY(targetPoint))
        )
    );
}


void sd_init() {
    trigger gt_loop;
    trigger gt_order;

    sf_phys_text_surface[0] = SURFACE_FAST_ICE;
    sf_phys_text_surface[1] = SURFACE_NORMAL_ICE;
    sf_phys_text_surface[2] = SURFACE_STRAIGHT_ICE;
    sf_phys_text_surface[3] = SURFACE_SNOW;
    sf_phys_text_surface[4] = SURFACE_LAND;
    sf_phys_text_surface[5] = SURFACE_REVERSE_FAST_ICE;
    sf_phys_text_surface[6] = SURFACE_REVERSE_ICE;
    sf_phys_text_surface[7] = SURFACE_LAND;

    gt_loop = TriggerCreate("sd_on_periodicCheck");
    TriggerExecute(gt_loop, false, false);

    gt_order = TriggerCreate("sd_on_heroOrder");
    // TODO unitref for all heroes
    TriggerAddEventUnitOrder(gt_order, null, AbilityCommand("move", 0));
    TriggerAddEventUnitOrder(gt_order, null, AbilityCommand("move", 1));

    TriggerCreate("sf_phys_on_move_execute");
    TriggerAddEventUnitAbility(TriggerFind("sf_phys_on_move_execute"), null, AbilityCommand("move", 0), c_unitAbilStageExecute, false);
    TriggerAddEventUnitAbility(TriggerFind("sf_phys_on_move_execute"), null, AbilityCommand("move", 1), c_unitAbilStageExecute, false);
}

int sd_getSurfaceAt(point pt) {
    int i;
    int x;
    int y;
    int intX;
    int intY;
    fixed pointX;
    fixed pointY;
    int surface;

    //
    for (i = 0; i < 16; i += 1) {
        if (!lv_surfaceRegions[i]) { continue; }
        if (!RegionContainsPoint(lv_surfaceRegions[i], pt)) { continue; }
        return i;
    }
    for (i = 0; i < SURFACE_REGIONS_MAX; i += 1) {
        if (lv_surfaceDynamicRegions[i].rg == null) { break; }
        if (!RegionContainsPoint(lv_surfaceDynamicRegions[i].rg, pt)) { continue; }
        return lv_surfaceDynamicRegions[i].type;
    }

    //
    pointX = PointGetX(pt) * 8.0;
    pointY = PointGetY(pt) * 8.0;
    intX = FloorI(pointX);
    intY = FloorI(pointY);
    surface = sd_mapTextXY(intX, intY);

    if (surface != SURFACE_SNOW) {
        return surface;
    }

    // this part is to introduce extended margin tolerance
    if (surface == SURFACE_SNOW) {
        for (y = -1; y <= 1; y += 1) {
            for (x = -1; x <= 1; x += 1) {
                surface = sd_mapTextXY(
                    FloorI( pointX + (IntToFixed(x) * 0.2) ),
                    FloorI( pointY + (IntToFixed(y) * 0.2) )
                );
                if (surface != SURFACE_SNOW) {
                    return surface;
                }
            }
        }
    }

    return surface;
}

bool sf_phys_is_point_on_ice(point pt) {
    return sf_phys_is_ice(sd_getSurfaceAt(pt), -1);
}

bool sf_phys_is_point_on_land(point pt) {
    return sf_phys_is_land(sd_getSurfaceAt(pt), -1);
}

bool sd_on_periodicCheck(bool testConds, bool runActions) {
    point currentPosition;
    structref<HERO> hero;
    fixed currentAngle;
    int currentSurface;
    int i;
    point targetPos;
    fixed iceSpeed;
    order currentOrder;
    fixed transition_speed_land = TURN_SPEED_ICE * 0.6; // if we would want to match IBE, it should be set to 0.8
    fixed transition_speed_ice = TURN_SPEED_ICE * 0.8;

    for (;;) {
        for (i = 1; i <= UnitGroupCount(gm_herogroup, c_unitCountAll); i += 1) {
            hero = gm_players[gm_getPlayerByUnit(UnitGroupUnit(gm_herogroup, i))].hero;
            if (!UnitIsValid(hero.mainUnit) || !UnitIsAlive(hero.mainUnit)) {
                continue;
            }

            cl_periodicTest(hero);

            if (sf_phys_is_unit_during_jump(hero.mainUnit)) {
                continue;
            }
            if (hero.paused) {
                continue;
            }

            currentPosition = UnitGetPosition(hero.mainUnit);
            currentAngle = UnitGetFacing(hero.guideUnit);
            currentSurface = sd_getSurfaceAt(currentPosition);

            // creep
            if (hero.propeling) {
                CreepModify(currentPosition, 0.35, true, false);
            }

            // transition : GROUND -> * ICE
            if (sf_phys_is_land(hero.surfaceType, -1) && sf_phys_is_ice(currentSurface, -1)) {
                UnitSetPosition(hero.guideUnit, UnitGetPosition(hero.mainUnit), false);

                // grap last move order from the queue and use it to guess angle
                // needed to support ibe glitch with shift clicking on no turn ice
                if (UnitOrderCount(hero.mainUnit) > 0) {
                    currentOrder = UnitOrder(hero.mainUnit, UnitOrderCount(hero.mainUnit) - 1);
                    if (
                        (
                            OrderGetAbilityCommand(currentOrder) == AbilityCommand("move", 0) ||
                            OrderGetAbilityCommand(currentOrder) == AbilityCommand("move", 1)
                        ) &&
                        DistanceBetweenPoints(UnitGetPosition(hero.mainUnit), OrderGetTargetPoint(currentOrder)) >= 0.3
                    ) {
                        hero.desiredAngle = AngleBetweenPoints(UnitGetPosition(hero.mainUnit), OrderGetTargetPoint(currentOrder));
                        // Dbg("[sliding/periodic] order used for angle guess");
                        // Dbg("[sliding/periodic] unit order count = " + IntToString(UnitOrderCount(hero.mainUnit)));
                    }
                }

                // Dbg("[sliding/periodic] entered ice at angle = " + FixedToString(currentAngle, 4));

                currentAngle = hero.desiredAngle;
                UnitIssueOrder(hero.mainUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);
                UnitIssueOrder(hero.guideUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);

                // transition : GROUND -> NORMAL ICE | FAST ICE
                if (
                    sf_phys_is_land(hero.surfaceType, -1) &&
                    (currentSurface == SURFACE_NORMAL_ICE || currentSurface == SURFACE_FAST_ICE)
                ) {
                    UnitSetFacing(hero.mainUnit, hero.desiredAngle, transition_speed_land);
                    UnitSetFacing(hero.guideUnit, hero.desiredAngle, transition_speed_land);
                }
                // transition : GROUND -> REVERSE ICE | FAST REVERSE ICE
                else if (
                    sf_phys_is_land(hero.surfaceType, -1) &&
                    (currentSurface == SURFACE_REVERSE_ICE || currentSurface == SURFACE_REVERSE_FAST_ICE)
                ) {
                    // if hero began on reverse ground we have make the turn immediately
                    // because remvoing HostSiteOps from actor is instant aswell
                    if (hero.surfaceType == SURFACE_REVERSE_GROUND) {
                        UnitSetFacing(hero.mainUnit, hero.desiredAngle + 180.0, 0);
                    }
                    else {
                        UnitSetFacing(hero.mainUnit, hero.desiredAngle + 180.0, transition_speed_land);
                    }
                    UnitSetFacing(hero.guideUnit, hero.desiredAngle, transition_speed_land);
                }
                // transition : GROUND -> 90DEG ICE
                else if (sf_phys_is_land(hero.surfaceType, -1) && currentSurface == SURFACE_90DEG_ICE) {
                    UnitSetFacing(hero.mainUnit, hero.desiredAngle + 90.0, transition_speed_land);
                    UnitSetFacing(hero.guideUnit, hero.desiredAngle, transition_speed_land);
                }
                // transition : GROUND -> STRAIGHT ICE
                else if (sf_phys_is_land(hero.surfaceType, -1) && currentSurface == SURFACE_STRAIGHT_ICE) {
                    UnitSetFacing(hero.guideUnit, hero.desiredAngle, 0.0);
                }
            }

            // transition : :NOT: STRAIGHT ICE -> * ICE
            if (sf_phys_is_ice(hero.surfaceType, SURFACE_STRAIGHT_ICE) && sf_phys_is_ice(currentSurface, -1)) {
                // transition : * ICE -> NORMAL ICE | FAST ICE
                if (
                    sf_phys_is_ice(hero.surfaceType, SURFACE_NORMAL_ICE) &&
                    sf_phys_is_ice(hero.surfaceType, SURFACE_FAST_ICE) &&
                    (currentSurface == SURFACE_NORMAL_ICE || currentSurface == SURFACE_FAST_ICE)
                ) {
                    UnitSetFacing(hero.mainUnit, currentAngle, transition_speed_ice);
                }
                // transition : * ICE -> REVERSE ICE | REVERSE FAST ICE
                else if (
                    sf_phys_is_ice(hero.surfaceType, SURFACE_REVERSE_ICE) &&
                    sf_phys_is_ice(hero.surfaceType, SURFACE_REVERSE_FAST_ICE) &&
                    (currentSurface == SURFACE_REVERSE_ICE || currentSurface == SURFACE_REVERSE_FAST_ICE)
                ) {
                    UnitSetFacing(hero.mainUnit, currentAngle + 180.0, transition_speed_ice);
                }
                // transition : * ICE -> 90DEG ICE
                else if (sf_phys_is_ice(hero.surfaceType, SURFACE_90DEG_ICE) && currentSurface == SURFACE_90DEG_ICE) {
                    UnitSetFacing(hero.mainUnit, currentAngle + 90.0, transition_speed_ice);
                }
                // transition : * ICE -> STRAIGHT ICE
                else if (sf_phys_is_ice(hero.surfaceType, SURFACE_STRAIGHT_ICE) && currentSurface == SURFACE_STRAIGHT_ICE) {
                    hero.noTurnFacing = currentAngle;
                    hero.noTurnProcess = true;
                }
            }
            else if (hero.surfaceType == SURFACE_STRAIGHT_ICE && currentSurface == SURFACE_STRAIGHT_ICE) {
                if (hero.noTurnProcess && currentAngle != hero.noTurnFacing) {
                    if (currentAngle != hero.desiredAngle) {
                        UnitIssueOrder(hero.guideUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);
                        UnitSetFacing(hero.guideUnit, currentAngle, 0.0);
                        hero.desiredAngle = currentAngle;
                    }
                    hero.noTurnProcess = false;
                }
            }

            // transition * -> SNOW
            if (currentSurface == SURFACE_SNOW) {
                UnitKill(hero.mainUnit);
                continue;
            }

            // transition * -> REVERSE GROUND
            if (hero.surfaceType != SURFACE_REVERSE_GROUND && currentSurface == SURFACE_REVERSE_GROUND) {
                if (hero.surfaceType == SURFACE_REVERSE_ICE) {
                    UnitSetFacing(hero.mainUnit, hero.desiredAngle, 0.0);
                }
                libNtve_gf_SendActorMessageToUnit(hero.mainUnit, "HostSiteOpsSet ::Host SOp180");
            }
            // transition REVERSE GROUND -> *
            else if (currentSurface != SURFACE_REVERSE_GROUND && hero.surfaceType == SURFACE_REVERSE_GROUND) {
                libNtve_gf_SendActorMessageToUnit(hero.mainUnit, "HostSiteOpsSet ::Host");
            }

            // fast ice deacceleration
            if (currentSurface == SURFACE_FAST_ICE || currentSurface == SURFACE_REVERSE_FAST_ICE) {
                hero.super_factor = FAST_ICE_MULTIPLIER;
            }
            else if (
                (hero.surfaceType == SURFACE_FAST_ICE || hero.surfaceType == SURFACE_REVERSE_FAST_ICE) &&
                sf_phys_is_land(currentSurface, -1)
            ) {
                hero.super_factor = 1.0;
            }

            hero.surfaceType = currentSurface;

            if (sf_phys_is_ice(hero.surfaceType, -1)) {
                iceSpeed = MOVE_SPEED_ICE;

                if (hero.surfaceType == SURFACE_FAST_ICE || hero.surfaceType == SURFACE_REVERSE_FAST_ICE) {
                    iceSpeed *= FAST_ICE_MULTIPLIER;
                }
                else {
                    if (hero.super_factor > 1.0) {
                        iceSpeed *= hero.super_factor;
                        hero.super_factor -= 0.05;
                    }
                }

                if (UnitHasBehavior(hero.mainUnit, "IceBoost")) {
                    iceSpeed += iceSpeed * 0.5;
                }
                if (hero.propeling || CreepIsPresent(currentPosition)) {
                    iceSpeed += iceSpeed * 0.5;
                }

                UnitSetPosition(
                    hero.mainUnit,
                    PointWithOffsetPolar(currentPosition, iceSpeed, currentAngle),
                    true
                );
                UnitSetPosition(
                    hero.guideUnit,
                    PointWithOffsetPolar(currentPosition, iceSpeed, currentAngle),
                    true
                );
            }
            else {
                hero.super_factor = 1.0;
            }
        }
        Wait(SF_PHYS_TICKS_INTERVAL, c_timeGame);
    }

    return true;
}

bool sd_on_heroOrder(bool testConds, bool runActions) {
    point targetPos;
    structref<HERO> hero;
    int currnetPlayer;
    order newOrder;

    currnetPlayer = gm_getPlayerByUnit(EventUnit());
    if (currnetPlayer == -1) {
        return false;
    }

    hero = gm_players[currnetPlayer].hero;

    targetPos = OrderGetTargetPosition(EventUnitOrder());

    if (sf_phys_restrain_next_order[UnitGetOwner(hero.mainUnit)]) {
        sf_phys_restrain_next_order[UnitGetOwner(hero.mainUnit)] = false;
        return false;
    }

    if (sf_phys_is_unit_during_jump(hero.mainUnit) || hero.paused || !sf_chal_initialized) {
        UnitIssueOrder(hero.mainUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);
        return true;
    }

    if (sf_phys_is_land(hero.surfaceType, -1)) {
        // TODO: this is now not needed as we handle desired approaching angle by listening for execute of move abilcmd
        // leaving it until rev ground will be supported with using new method
        if (hero.surfaceType == SURFACE_REVERSE_GROUND) {
            newOrder = sd_makeRevGroundOrder(hero.mainUnit, EventUnitOrder());
            UnitIssueOrder(hero.mainUnit, newOrder, c_orderQueueReplace);
            sf_phys_restrain_next_order[UnitGetOwner(hero.mainUnit)] = true;
        }
    }
    else {
        UnitIssueOrder(hero.mainUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);
        if (hero.surfaceType != SURFACE_STRAIGHT_ICE && !hero.supress_turn) {
            UnitIssueOrder(hero.guideUnit, Order(AbilityCommand("stop", 0)), c_orderQueueReplace);
            hero.desiredAngle = AngleBetweenPoints(
                UnitGetPosition(hero.mainUnit),
                targetPos
            );
            if (
                hero.surfaceType == SURFACE_NORMAL_ICE ||
                hero.surfaceType == SURFACE_FAST_ICE
            ) {
                UnitSetFacing(hero.mainUnit, hero.desiredAngle, TURN_SPEED_ICE);
                UnitSetFacing(hero.guideUnit, hero.desiredAngle, TURN_SPEED_ICE);
            }
            else if (
                hero.surfaceType == SURFACE_REVERSE_ICE ||
                hero.surfaceType == SURFACE_REVERSE_FAST_ICE
            ) {
                hero.desiredAngle += 180.0;
                UnitSetFacing(hero.mainUnit, hero.desiredAngle + 180.0, TURN_SPEED_ICE);
                UnitSetFacing(hero.guideUnit, hero.desiredAngle, TURN_SPEED_ICE);
            }
            else if (hero.surfaceType == SURFACE_90DEG_ICE) {
                hero.desiredAngle += 90.0;
                UnitSetFacing(hero.mainUnit, hero.desiredAngle + 90.0, TURN_SPEED_ICE);
                UnitSetFacing(hero.guideUnit, hero.desiredAngle, TURN_SPEED_ICE);
            }
        }
        else {
            SoundPlay(SoundLink("UI_GenericError", -1), PlayerGroupSingle(EventPlayer()), 100.0, 0.0);
        }
    }

    return true;
}

bool sf_phys_on_move_execute(bool testConds, bool runActions) {
    structref<HERO> hero;
    int currentPlayer;
    order newOrder;

    currentPlayer = gm_getPlayerByUnit(EventUnit());
    if (currentPlayer == -1) {
        return false;
    }

    hero = gm_players[currentPlayer].hero;

    // Dbg("[phys/on_move] hero surface = " + IntToString(hero.surfaceType));
    if (sf_phys_is_land(hero.surfaceType, -1)) {
        // TODO: handle rev ground - probably not working as it should?
        hero.desiredAngle = AngleBetweenPoints(
            UnitGetPosition(hero.mainUnit),
            EventUnitTargetPoint()
        );
        UnitSetFacing(hero.guideUnit, hero.desiredAngle, TURN_SPEED_ICE * 0.8);
    }
    return true;
}
