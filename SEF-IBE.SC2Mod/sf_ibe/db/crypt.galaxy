const int DB_CRYPT_ERR_CHECKSUM_MISSMATCH = 1;
const int DB_CRYPT_ERR_NOT_VALID = 2;

const string DB_CRYPT_BASE = "0ia1l2p34xq5j6HE7W89LbcdDefghkRmnKorstuvwyzAMBFCGIJNQOPTUXSVYZ!$%/()=?,.;:_^#+* @{[]}|~-`";

static string db_crypt_calculate_checksum(string data) {
    int i;
    int checksum = 0;
    string ret;

    for (i = 1; i <= StringLength(data); i += 1) {
        checksum ^= (StringFind(DB_CRYPT_BASE, StringSub(data, i, i), true) - 1) | PowI(2, IntToFixed(i));
    }

    ret = db_stream_serialize_int(checksum);

    return string_fill("0", 4 - StringLength(ret)) + ret;
}

int db_crypt_validate(string encrypted_data) {
    string providedChecksum;
    string calculatedChecksum;
    string buff;

    buff = StringSub(encrypted_data, 1, StringLength(encrypted_data) - 4);
    providedChecksum = StringSub(encrypted_data, StringLength(encrypted_data) - 3, StringLength(encrypted_data));
    calculatedChecksum = db_crypt_calculate_checksum(buff);

    // Dbg("[crypt/validate] input = " + encrypted_data);

    // check if it contains any data excluding checksum
    if (StringLength(encrypted_data) <= 4) {
        return DB_CRYPT_ERR_NOT_VALID;
    }

    // verify checksum
    if (providedChecksum != calculatedChecksum) {
        // Dbg("org checksum: " + providedChecksum);
        // Dbg("calc checksum: " + calculatedChecksum);
        // Dbg("calc chunk: " + buff);
        // Dbg("[crypt/decrypt] checksum missmatch");
        return DB_CRYPT_ERR_CHECKSUM_MISSMATCH;
    }

    return 0;
}

string db_crypt_decrypt(int enc_key, string encrypted_data) {
    int i;
    int seed;
    int tmp;
    string buff;

    // Dbg("[crypt/decrypt] input = " + encrypted_data);

    i = StringLength(encrypted_data);

    encrypted_data = StringSub(encrypted_data, 1, StringLength(encrypted_data) - 4);

    for (i = 1; i <= StringLength(encrypted_data); i += 1) {
        seed += PowI(StringLength(encrypted_data), IntToFixed(i)) + enc_key;
        tmp = AbsI(seed) % StringLength(DB_CRYPT_BASE);
        tmp = (StringFind(DB_CRYPT_BASE, StringSub(encrypted_data, i, i), true) - tmp - 1) % StringLength(DB_CRYPT_BASE);
        if (tmp < 0) {
            tmp += StringLength(DB_CRYPT_BASE);
        }

        tmp += 1;
        buff += StringSub(DB_CRYPT_BASE, tmp, tmp);
    }

    // Dbg("[crypt/decrypt] output = " + buff);

    return buff;
}

string db_crypt_encrypt(int enc_key, string input) {
    string encrypted_data;
    string checksum;
    int i;
    int seed;
    int tmp;

    // Dbg("[crypt/encrypt] enc_key = " + IntToString(enc_key));
    // Dbg("[crypt/encrypt] input = " + input);

    encrypted_data = input;
    i = StringLength(encrypted_data);

    while (i >= 1) {
        if (StringFind(DB_CRYPT_BASE, StringSub(encrypted_data, i, i), true) == -1) {
            encrypted_data = StringReplace(encrypted_data, "", i, i);
        }
        i -= 1;
    }

    for (i = 1; i <= StringLength(encrypted_data); i += 1) {
        seed += PowI(StringLength(encrypted_data), IntToFixed(i)) + enc_key;
        tmp = AbsI(seed) % StringLength(DB_CRYPT_BASE);
        tmp = (tmp + StringFind(DB_CRYPT_BASE, StringSub(encrypted_data, i, i), true) - 1) % StringLength(DB_CRYPT_BASE);

        tmp += 1;
        encrypted_data = StringReplace(encrypted_data, StringSub(DB_CRYPT_BASE, tmp, tmp), i, i);
        // Dbg(IntToString(
        // 	tmp
        // ));
        // Dbg(IntToString(seed));
        // Dbg(IntToString(tmp));
    }

    checksum = db_crypt_calculate_checksum(encrypted_data);
    // Dbg("[crypt/encrypt] checksum = " + checksum);
    // Dbg("[crypt/encrypt] output = " + encrypted_data);

    return encrypted_data + checksum;
}
